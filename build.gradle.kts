import org.gradle.api.tasks.testing.logging.TestLogEvent

/*
 * This file was generated by the Gradle 'init' task.
 *
 * This is a general purpose Gradle build.
 * Learn more about Gradle by exploring our Samples at https://docs.gradle.org/8.14/samples
 */
plugins {
    java

    id("jacoco")
    id("jacoco-report-aggregation")
    id("com.github.spotbugs") version "6.2.0"
}

allprojects {
    repositories {
        mavenCentral()
    }
}

subprojects {
    apply(plugin = "java")
    apply(plugin = "jacoco")
    apply(plugin = "com.github.spotbugs")

    group = ProjectInfo.group
    version = ProjectInfo.version

    tasks.withType<JavaCompile> {
        options.encoding = "UTF-8"
        options.release.set(JavaVersion.VERSION_24.majorVersion.toInt())
    }

    tasks.withType<Test> {
        useJUnitPlatform()

        testLogging {
            lifecycle {
                events = mutableSetOf(TestLogEvent.SKIPPED, TestLogEvent.FAILED)

                showExceptions = true
                showCauses = true
                showStackTraces = true

                info.events = lifecycle.events
                info.exceptionFormat = lifecycle.exceptionFormat
            }
        }

        fun center(s: String?, maxWidth: Int): String {
            val str = s ?: ""
            if (str.length >= maxWidth) {
                return str.substring(0, maxWidth - 3) + "..."
            }

            val leftPadding = (maxWidth - str.length) / 2
            return str.padStart(str.length + leftPadding).padEnd(maxWidth)
        }

        // global state to store the test results
        val successTests: MutableList<TestDescriptor> = mutableListOf()
        val skippedTests: MutableList<TestDescriptor> = mutableListOf()
        val failedTests: MutableList<TestDescriptor> = mutableListOf()

        // @formatter:off
        val resetColor  = "\u001B[0m"
        val redColor    = "\u001B[31m"
        val greenColor  = "\u001B[32m"
        val yellowColor = "\u001B[33m"

        val classNameColWidth = 40
        val testNameColWidth  = 80
        val statusColWidth    = 10
        // @formatter:on

        val tableBorder =
            "+" + ("-".repeat(classNameColWidth)) + "+" + ("-".repeat(testNameColWidth)) + "+" + ("-".repeat(
                statusColWidth
            )) + "+"
        val tableHeader =
            "|${center("Class Name", classNameColWidth)}|${center("Test Name", testNameColWidth)}|${
                center(
                    "Status",
                    statusColWidth
                )
            }|"



        addTestListener(object : TestListener {
            override fun beforeSuite(suite: TestDescriptor?) {}

            override fun beforeTest(testDescriptor: TestDescriptor?) {}

            override fun afterTest(testDescriptor: TestDescriptor?, result: TestResult?) {
                when (result?.resultType) {
                    TestResult.ResultType.SUCCESS -> testDescriptor?.let { successTests.add(it) }
                    TestResult.ResultType.SKIPPED -> testDescriptor?.let { skippedTests.add(it) }
                    TestResult.ResultType.FAILURE -> testDescriptor?.let { failedTests.add(it) }
                    null -> assert(true) { "Unreachable" }
                }
            }

            override fun afterSuite(suite: TestDescriptor?, result: TestResult?) {
                if (suite?.parent == null) {
                    logger.lifecycle("\n############################### Test Run Summary ###############################\n")
                    logTestResultsTable()
                    logStats()
                    logger.lifecycle("\n################################################################################\n")
                }
            }

            private fun logTestResultsTable() {
                logger.lifecycle(tableBorder)
                logger.lifecycle(tableHeader)
                logger.lifecycle(tableBorder)

                successTests.forEach {
                    logTestResult(it, "SUCCESS", greenColor)
                }

                skippedTests.forEach {
                    logTestResult(it, "SKIPPED", yellowColor)
                }

                failedTests.forEach {
                    logTestResult(it, "FAILED", redColor)
                }

                logger.lifecycle(tableBorder)
            }

            private fun logTestResult(testDescriptor: TestDescriptor?, result: String?, color: String) {
                // Extract class name from the test descriptor
                val className = extractClassName(testDescriptor)
                val testName = testDescriptor?.displayName ?: "Unknown Test"

                logger.lifecycle(
                    "|${center(className, classNameColWidth)}|${
                        center(
                            testName,
                            testNameColWidth
                        )
                    }|${color}${center(result, statusColWidth)}$resetColor|"
                )
            }

            private fun extractClassName(testDescriptor: TestDescriptor?): String {
                if (testDescriptor == null) return "Unknown"

                // Try to get the class name from the test descriptor
                val className = testDescriptor.className
                if (className != null) {
                    // Return simple class name (without package)
                    return className.substringAfterLast(".")
                }

                // Fallback: try to extract from parent
                val parentName = testDescriptor.parent?.displayName
                if (parentName != null && parentName.contains(".")) {
                    return parentName.substringAfterLast(".")
                }

                return parentName ?: "Unknown"
            }

            private fun logStats() {
                val successCount = successTests.size
                val skippedCount = skippedTests.size
                val failedCount = failedTests.size
                val totalCount = successCount + skippedCount + failedCount

                logger.lifecycle("\nTest run statistics")
                logger.lifecycle("------------------------")

                logger.lifecycle("Total  : $totalCount")
                logger.lifecycle("Success: $successCount  (${"%.2f".format((successCount.toDouble() / totalCount) * 100)}%)")
                logger.lifecycle("Skipped: $skippedCount  (${"%.2f".format((skippedCount.toDouble() / totalCount) * 100)}%)")
                logger.lifecycle("Failed : $failedCount  (${"%.2f".format((failedCount.toDouble() / totalCount) * 100)}%)")

                logger.lifecycle("------------------------")
            }
        })

        finalizedBy(tasks.jacocoTestReport)

        configure<JacocoTaskExtension> {
            isEnabled = true
        }

        tasks.withType<JacocoReport> {
            dependsOn(tasks.test)

            reports {
                html.required.set(true)
                xml.required.set(true)
                csv.required.set(false)
            }
        }

        tasks.withType<Jar> {
            archiveFileName.set("${rootProject.name}-${project.name}-${ProjectInfo.version}.jar")
        }
    }
}

reporting {
    reports {
        val junit by creating(JacocoCoverageReport::class) {
            testSuiteName = "test"
        }
    }
}

tasks.check {
    dependsOn(tasks.named<JacocoReport>("testCodeCoverageReport"))
}